{"version":3,"file":"static/js/769.ba0c8b14.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/engine/browser/Core/Particle.js"],"sourcesContent":["import { Vector, Vector3d } from \"./Utils/Vectors.js\";\nimport { calcExactPositionOrRandomFromSize, clamp, degToRad, getDistance, getParticleBaseVelocity, getParticleDirectionAngle, getRandom, getRangeValue, randomInRange, setRangeValue, } from \"../Utils/NumberUtils.js\";\nimport { deepExtend, getPosition, initParticleNumericAnimationValue, isInArray, itemFromSingleOrMultiple, } from \"../Utils/Utils.js\";\nimport { errorPrefix, millisecondsToSeconds } from \"./Utils/Constants.js\";\nimport { getHslFromAnimation, rangeColorToRgb } from \"../Utils/ColorUtils.js\";\nimport { Interactivity } from \"../Options/Classes/Interactivity/Interactivity.js\";\nimport { alterHsl } from \"../Utils/CanvasUtils.js\";\nimport { loadParticlesOptions } from \"../Utils/OptionsUtils.js\";\nconst defaultRetryCount = 0, double = 2, half = 0.5, squareExp = 2;\nfunction loadEffectData(effect, effectOptions, id, reduceDuplicates) {\n    const effectData = effectOptions.options[effect];\n    if (!effectData) {\n        return;\n    }\n    return deepExtend({\n        close: effectOptions.close,\n        fill: effectOptions.fill,\n    }, itemFromSingleOrMultiple(effectData, id, reduceDuplicates));\n}\nfunction loadShapeData(shape, shapeOptions, id, reduceDuplicates) {\n    const shapeData = shapeOptions.options[shape];\n    if (!shapeData) {\n        return;\n    }\n    return deepExtend({\n        close: shapeOptions.close,\n        fill: shapeOptions.fill,\n    }, itemFromSingleOrMultiple(shapeData, id, reduceDuplicates));\n}\nfunction fixOutMode(data) {\n    if (!isInArray(data.outMode, data.checkModes)) {\n        return;\n    }\n    const diameter = data.radius * double;\n    if (data.coord > data.maxCoord - diameter) {\n        data.setCb(-data.radius);\n    }\n    else if (data.coord < diameter) {\n        data.setCb(data.radius);\n    }\n}\nexport class Particle {\n    constructor(engine, container) {\n        this.container = container;\n        this._calcPosition = (container, position, zIndex, tryCount = defaultRetryCount) => {\n            for (const [, plugin] of container.plugins) {\n                const pluginPos = plugin.particlePosition !== undefined ? plugin.particlePosition(position, this) : undefined;\n                if (pluginPos) {\n                    return Vector3d.create(pluginPos.x, pluginPos.y, zIndex);\n                }\n            }\n            const canvasSize = container.canvas.size, exactPosition = calcExactPositionOrRandomFromSize({\n                size: canvasSize,\n                position: position,\n            }), pos = Vector3d.create(exactPosition.x, exactPosition.y, zIndex), radius = this.getRadius(), outModes = this.options.move.outModes, fixHorizontal = (outMode) => {\n                fixOutMode({\n                    outMode,\n                    checkModes: [\"bounce\"],\n                    coord: pos.x,\n                    maxCoord: container.canvas.size.width,\n                    setCb: (value) => (pos.x += value),\n                    radius,\n                });\n            }, fixVertical = (outMode) => {\n                fixOutMode({\n                    outMode,\n                    checkModes: [\"bounce\"],\n                    coord: pos.y,\n                    maxCoord: container.canvas.size.height,\n                    setCb: (value) => (pos.y += value),\n                    radius,\n                });\n            };\n            fixHorizontal(outModes.left ?? outModes.default);\n            fixHorizontal(outModes.right ?? outModes.default);\n            fixVertical(outModes.top ?? outModes.default);\n            fixVertical(outModes.bottom ?? outModes.default);\n            if (this._checkOverlap(pos, tryCount)) {\n                const increment = 1;\n                return this._calcPosition(container, undefined, zIndex, tryCount + increment);\n            }\n            return pos;\n        };\n        this._calculateVelocity = () => {\n            const baseVelocity = getParticleBaseVelocity(this.direction), res = baseVelocity.copy(), moveOptions = this.options.move;\n            if (moveOptions.direction === \"inside\" || moveOptions.direction === \"outside\") {\n                return res;\n            }\n            const rad = degToRad(getRangeValue(moveOptions.angle.value)), radOffset = degToRad(getRangeValue(moveOptions.angle.offset)), range = {\n                left: radOffset - rad * half,\n                right: radOffset + rad * half,\n            };\n            if (!moveOptions.straight) {\n                res.angle += randomInRange(setRangeValue(range.left, range.right));\n            }\n            if (moveOptions.random && typeof moveOptions.speed === \"number\") {\n                res.length *= getRandom();\n            }\n            return res;\n        };\n        this._checkOverlap = (pos, tryCount = defaultRetryCount) => {\n            const collisionsOptions = this.options.collisions, radius = this.getRadius();\n            if (!collisionsOptions.enable) {\n                return false;\n            }\n            const overlapOptions = collisionsOptions.overlap;\n            if (overlapOptions.enable) {\n                return false;\n            }\n            const retries = overlapOptions.retries, minRetries = 0;\n            if (retries >= minRetries && tryCount > retries) {\n                throw new Error(`${errorPrefix} particle is overlapping and can't be placed`);\n            }\n            return !!this.container.particles.find((particle) => getDistance(pos, particle.position) < radius + particle.getRadius());\n        };\n        this._getRollColor = (color) => {\n            if (!color || !this.roll || (!this.backColor && !this.roll.alter)) {\n                return color;\n            }\n            const rollFactor = 1, none = 0, backFactor = this.roll.horizontal && this.roll.vertical ? double * rollFactor : rollFactor, backSum = this.roll.horizontal ? Math.PI * half : none, rolled = Math.floor(((this.roll.angle ?? none) + backSum) / (Math.PI / backFactor)) % double;\n            if (!rolled) {\n                return color;\n            }\n            if (this.backColor) {\n                return this.backColor;\n            }\n            if (this.roll.alter) {\n                return alterHsl(color, this.roll.alter.type, this.roll.alter.value);\n            }\n            return color;\n        };\n        this._initPosition = (position) => {\n            const container = this.container, zIndexValue = getRangeValue(this.options.zIndex.value), minZ = 0;\n            this.position = this._calcPosition(container, position, clamp(zIndexValue, minZ, container.zLayers));\n            this.initialPosition = this.position.copy();\n            const canvasSize = container.canvas.size, defaultRadius = 0;\n            this.moveCenter = {\n                ...getPosition(this.options.move.center, canvasSize),\n                radius: this.options.move.center.radius ?? defaultRadius,\n                mode: this.options.move.center.mode ?? \"percent\",\n            };\n            this.direction = getParticleDirectionAngle(this.options.move.direction, this.position, this.moveCenter);\n            switch (this.options.move.direction) {\n                case \"inside\":\n                    this.outType = \"inside\";\n                    break;\n                case \"outside\":\n                    this.outType = \"outside\";\n                    break;\n            }\n            this.offset = Vector.origin;\n        };\n        this._engine = engine;\n    }\n    destroy(override) {\n        if (this.unbreakable || this.destroyed) {\n            return;\n        }\n        this.destroyed = true;\n        this.bubble.inRange = false;\n        this.slow.inRange = false;\n        const container = this.container, pathGenerator = this.pathGenerator, shapeDrawer = container.shapeDrawers.get(this.shape);\n        shapeDrawer?.particleDestroy?.(this);\n        for (const [, plugin] of container.plugins) {\n            plugin.particleDestroyed?.(this, override);\n        }\n        for (const updater of container.particles.updaters) {\n            updater.particleDestroyed?.(this, override);\n        }\n        pathGenerator?.reset(this);\n        this._engine.dispatchEvent(\"particleDestroyed\", {\n            container: this.container,\n            data: {\n                particle: this,\n            },\n        });\n    }\n    async draw(delta) {\n        const container = this.container, canvas = container.canvas;\n        for (const [, plugin] of container.plugins) {\n            await canvas.drawParticlePlugin(plugin, this, delta);\n        }\n        await canvas.drawParticle(this, delta);\n    }\n    getFillColor() {\n        return this._getRollColor(this.bubble.color ?? getHslFromAnimation(this.color));\n    }\n    getMass() {\n        return this.getRadius() ** squareExp * Math.PI * half;\n    }\n    getPosition() {\n        return {\n            x: this.position.x + this.offset.x,\n            y: this.position.y + this.offset.y,\n            z: this.position.z,\n        };\n    }\n    getRadius() {\n        return this.bubble.radius ?? this.size.value;\n    }\n    getStrokeColor() {\n        return this._getRollColor(this.bubble.color ?? getHslFromAnimation(this.strokeColor));\n    }\n    async init(id, position, overrideOptions, group) {\n        const container = this.container, engine = this._engine;\n        this.id = id;\n        this.group = group;\n        this.effectClose = true;\n        this.effectFill = true;\n        this.shapeClose = true;\n        this.shapeFill = true;\n        this.pathRotation = false;\n        this.lastPathTime = 0;\n        this.destroyed = false;\n        this.unbreakable = false;\n        this.rotation = 0;\n        this.misplaced = false;\n        this.retina = {\n            maxDistance: {},\n        };\n        this.outType = \"normal\";\n        this.ignoresResizeRatio = true;\n        const pxRatio = container.retina.pixelRatio, mainOptions = container.actualOptions, particlesOptions = loadParticlesOptions(this._engine, container, mainOptions.particles), effectType = particlesOptions.effect.type, shapeType = particlesOptions.shape.type, { reduceDuplicates } = particlesOptions;\n        this.effect = itemFromSingleOrMultiple(effectType, this.id, reduceDuplicates);\n        this.shape = itemFromSingleOrMultiple(shapeType, this.id, reduceDuplicates);\n        const effectOptions = particlesOptions.effect, shapeOptions = particlesOptions.shape;\n        if (overrideOptions) {\n            if (overrideOptions.effect?.type) {\n                const overrideEffectType = overrideOptions.effect.type, effect = itemFromSingleOrMultiple(overrideEffectType, this.id, reduceDuplicates);\n                if (effect) {\n                    this.effect = effect;\n                    effectOptions.load(overrideOptions.effect);\n                }\n            }\n            if (overrideOptions.shape?.type) {\n                const overrideShapeType = overrideOptions.shape.type, shape = itemFromSingleOrMultiple(overrideShapeType, this.id, reduceDuplicates);\n                if (shape) {\n                    this.shape = shape;\n                    shapeOptions.load(overrideOptions.shape);\n                }\n            }\n        }\n        this.effectData = loadEffectData(this.effect, effectOptions, this.id, reduceDuplicates);\n        this.shapeData = loadShapeData(this.shape, shapeOptions, this.id, reduceDuplicates);\n        particlesOptions.load(overrideOptions);\n        const effectData = this.effectData;\n        if (effectData) {\n            particlesOptions.load(effectData.particles);\n        }\n        const shapeData = this.shapeData;\n        if (shapeData) {\n            particlesOptions.load(shapeData.particles);\n        }\n        const interactivity = new Interactivity(engine, container);\n        interactivity.load(container.actualOptions.interactivity);\n        interactivity.load(particlesOptions.interactivity);\n        this.interactivity = interactivity;\n        this.effectFill = effectData?.fill ?? particlesOptions.effect.fill;\n        this.effectClose = effectData?.close ?? particlesOptions.effect.close;\n        this.shapeFill = shapeData?.fill ?? particlesOptions.shape.fill;\n        this.shapeClose = shapeData?.close ?? particlesOptions.shape.close;\n        this.options = particlesOptions;\n        const pathOptions = this.options.move.path;\n        this.pathDelay = getRangeValue(pathOptions.delay.value) * millisecondsToSeconds;\n        if (pathOptions.generator) {\n            this.pathGenerator = this._engine.getPathGenerator(pathOptions.generator);\n            if (this.pathGenerator && container.addPath(pathOptions.generator, this.pathGenerator)) {\n                await this.pathGenerator.init(container);\n            }\n        }\n        container.retina.initParticle(this);\n        this.size = initParticleNumericAnimationValue(this.options.size, pxRatio);\n        this.bubble = {\n            inRange: false,\n        };\n        this.slow = {\n            inRange: false,\n            factor: 1,\n        };\n        this._initPosition(position);\n        this.initialVelocity = this._calculateVelocity();\n        this.velocity = this.initialVelocity.copy();\n        const decayOffset = 1;\n        this.moveDecay = decayOffset - getRangeValue(this.options.move.decay);\n        const particles = container.particles;\n        particles.setLastZIndex(this.position.z);\n        this.zIndexFactor = this.position.z / container.zLayers;\n        this.sides = 24;\n        let effectDrawer = container.effectDrawers.get(this.effect);\n        if (!effectDrawer) {\n            effectDrawer = this._engine.getEffectDrawer(this.effect);\n            if (effectDrawer) {\n                container.effectDrawers.set(this.effect, effectDrawer);\n            }\n        }\n        if (effectDrawer?.loadEffect) {\n            await effectDrawer.loadEffect(this);\n        }\n        let shapeDrawer = container.shapeDrawers.get(this.shape);\n        if (!shapeDrawer) {\n            shapeDrawer = this._engine.getShapeDrawer(this.shape);\n            if (shapeDrawer) {\n                container.shapeDrawers.set(this.shape, shapeDrawer);\n            }\n        }\n        if (shapeDrawer?.loadShape) {\n            await shapeDrawer.loadShape(this);\n        }\n        const sideCountFunc = shapeDrawer?.getSidesCount;\n        if (sideCountFunc) {\n            this.sides = sideCountFunc(this);\n        }\n        this.spawning = false;\n        this.shadowColor = rangeColorToRgb(this.options.shadow.color);\n        for (const updater of particles.updaters) {\n            await updater.init(this);\n        }\n        for (const mover of particles.movers) {\n            await mover.init?.(this);\n        }\n        await effectDrawer?.particleInit?.(container, this);\n        await shapeDrawer?.particleInit?.(container, this);\n        for (const [, plugin] of container.plugins) {\n            plugin.particleCreated?.(this);\n        }\n    }\n    isInsideCanvas() {\n        const radius = this.getRadius(), canvasSize = this.container.canvas.size, position = this.position;\n        return (position.x >= -radius &&\n            position.y >= -radius &&\n            position.y <= canvasSize.height + radius &&\n            position.x <= canvasSize.width + radius);\n    }\n    isVisible() {\n        return !this.destroyed && !this.spawning && this.isInsideCanvas();\n    }\n    reset() {\n        for (const updater of this.container.particles.updaters) {\n            updater.reset?.(this);\n        }\n    }\n}\n"],"names":["half","fixOutMode","data","isInArray","outMode","checkModes","diameter","radius","coord","maxCoord","setCb","Particle","constructor","engine","container","_this","this","_calcPosition","position","zIndex","_outModes$left","_outModes$right","_outModes$top","_outModes$bottom","tryCount","arguments","length","undefined","plugin","plugins","pluginPos","particlePosition","Vector3d","create","x","y","canvasSize","canvas","size","exactPosition","calcExactPositionOrRandomFromSize","pos","getRadius","outModes","options","move","fixHorizontal","width","value","fixVertical","height","left","default","right","top","bottom","_checkOverlap","increment","_calculateVelocity","res","getParticleBaseVelocity","direction","copy","moveOptions","rad","degToRad","getRangeValue","angle","radOffset","offset","range","straight","randomInRange","setRangeValue","random","speed","getRandom","collisionsOptions","collisions","enable","overlapOptions","overlap","retries","Error","concat","errorPrefix","particles","find","particle","getDistance","_getRollColor","color","_this$roll$angle","roll","backColor","alter","backFactor","horizontal","vertical","double","backSum","Math","PI","floor","alterHsl","type","_initPosition","_this$options$move$ce","_this$options$move$ce2","zIndexValue","clamp","zLayers","initialPosition","moveCenter","getPosition","center","mode","getParticleDirectionAngle","outType","Vector","origin","_engine","destroy","override","_shapeDrawer$particle","unbreakable","destroyed","bubble","inRange","slow","pathGenerator","shapeDrawer","shapeDrawers","get","shape","particleDestroy","call","_plugin$particleDestr","particleDestroyed","updater","updaters","_updater$particleDest","reset","dispatchEvent","draw","delta","drawParticlePlugin","drawParticle","getFillColor","_this$bubble$color","getHslFromAnimation","getMass","z","_this$bubble$radius","getStrokeColor","_this$bubble$color2","strokeColor","init","id","overrideOptions","group","_effectData$fill","_effectData$close","_shapeData$fill","_shapeData$close","_effectDrawer","_shapeDrawer","_shapeDrawer2","_effectDrawer2","_effectDrawer2$partic","_shapeDrawer3","_shapeDrawer3$particl","effectClose","effectFill","shapeClose","shapeFill","pathRotation","lastPathTime","rotation","misplaced","retina","maxDistance","ignoresResizeRatio","pxRatio","pixelRatio","mainOptions","actualOptions","particlesOptions","loadParticlesOptions","effectType","effect","shapeType","reduceDuplicates","itemFromSingleOrMultiple","effectOptions","shapeOptions","_overrideOptions$effe","_overrideOptions$shap","overrideEffectType","load","overrideShapeType","effectData","deepExtend","close","fill","loadEffectData","shapeData","loadShapeData","interactivity","Interactivity","pathOptions","path","pathDelay","delay","millisecondsToSeconds","generator","getPathGenerator","addPath","initParticle","initParticleNumericAnimationValue","factor","initialVelocity","velocity","moveDecay","decay","setLastZIndex","zIndexFactor","sides","effectDrawer","effectDrawers","getEffectDrawer","set","loadEffect","getShapeDrawer","loadShape","sideCountFunc","getSidesCount","spawning","shadowColor","rangeColorToRgb","shadow","mover","movers","_mover$init","particleInit","_plugin$particleCreat","particleCreated","isInsideCanvas","isVisible","_updater$reset"],"sourceRoot":""}